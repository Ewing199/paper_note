# C语言学习总结
## 一. const,static,extern的使用
### 1.1 const
> **作用**
1. 修饰右边的基本变量和指针变量;
2. 被const修饰的变量只读,也就是只能获取，不能修改
> **与宏定义的比较**
> 1. 编译时刻  宏:预编译 const:编译
> 2. 编译检查  宏没有编译检查,不会报编译错误；const有编译检查，会报编译错误
> 3. 宏的好处  宏能定义一些函数，方法,但是const不可以
> 4. 宏的坏处  大量使用宏,会导致预编译时间过长。

### 1.2 static
> **作用**
1. 修饰局部变量:被static修饰的局部变量，可以延长生命周期，生命周期跟整个应用程序一致；被static修饰的局部变量，只会分配一次内存;
2. 修饰全局变量:被static修饰的全局变量，作用域会修改，生命周期不会改,只能在当前文件下使用
### 1.3 extern
> **作用**
1. 声明外部全局变量
2. 工作原理：
```
graph LR
当前文件 --> 其他文件
```
### 1.4 extern 和 const结合使用
使用场景：多个文件中经常使用的统一字符串常量

## 二. 循环调试问题
     
## 三. 动态分配内存
### 错误情况
    申请了内存之后无法释放

1.内存分配不成功，却使用了指针

*解决方法：注意空指针检测 if(p!=null)* 

2.内存分配成功，未初始化就使用
   
*解决办法：申请完内存空间要赋值，不要误认为缺省为0
    malloc--->memset*

3.分配初始化成功，但数组越界
*解决办法：注意对数组的最大值进行判断*

4.忘记释放内存

### 错误场景
内存覆盖：memcpy(p,q,size)：p>=size

内存越界：memcpy(p,q,size)：q<=size

**内存泄漏**：
- 重新赋值：内存指针指向其他位置时，原内存地址没有指向该位置的引用，导致内存泄漏
- 先释放父块：父指针的某一块指向子指针的首地址。不能直接释放父块，应先遍历到子节点的位置释放，在释放父节点。free(father->son)>>>free(father)

- 返回值的错误处理

跟踪申请的内存，注意适当的时候要释放

访问空指针错误

5. 
## 四. 参数传递
## 五. 字节对齐
在结构体里，CPU为了使编译器更高效会强制进行字节对齐操作，
 
 gdb /tmp/EAS_tmp.elf /wellav_data/log/core.EAS_tmp.elf
# C语言书籍
1.深入理解计算机系统
2.C语言三剑客——C和指针
3.C语言专家编程
4.C PRIMER PLUS

# 六. 内存四区
代码被load到内存，分成四个区，操作系统刚找到main函数入口执行
## 1.栈区
编译器自动分配释放，存放函数参数值，局部变量
### 1.1 栈的增长
向下增长，数据从地址大到地址小依次入栈，数组是从小到大入栈
### 1.2函数栈
1. 主调函数分配的内存空间（堆，栈，全局区）可以在被调函数中使用
2. 被调函数只有堆区和全局区可以在主调函数使用(返回值，函数参数)
## 2.堆区
程序员分配释放：动态内存的分配释放
## 3.数据区
### 3.1 全局变量，静态变量区
分为初始化和未初始化段
1. BBS段：未初始化或初始化为0的段，只占运行内存空间，不占文件空间
2. DATA段：初始化过（非0）的非const全局变量，既占文件空间，有占运行空间
### 3.2 常量区
申请后这片区域不能修改，只能取用
## 4.代码区
函数体二进制代码
# 七.指针详解
```
int p; //这是一个普通的整型变量  
int *p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针  
int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组  
int *p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组  
int (*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针  
int **p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,最多只考虑一级指针.  
int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据  
Int (*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针  
int *(*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 

```
## 1.理解指针
### 1.1 指针的类型*
去掉变量名，剩余的是指针的类型
### 1.2指针指向的类型*
去掉变量名和指针左边的“*”
### 1.3 指针的值（32位）
指针指向的内存区或地址，指针的值即为指向"xx"为首的一片内存区域，指针指向他的首地址
### 1.4指针本身占据的内存区
32位平台里占据4个字节长度

## 2.指针的运算
指针的运算是，是像原指针的方向移动了n*sizeof(ptrold)个字节
```math
prtnew = ptrold+n*sizeof(ptrold)
```
## 3.运算符&和*
*p 的结果是p所指向的东西，这个东西有这些特点：它的类型是p 指向的类型，它所占用的地址是p所指向的地址

## 4.数组和指针
数组名代表数组本身，如果把数组看做指针本身，他指向数组的0单元

# 八.清除缓冲区
C语言使用getchar和scanf读入字符，可能读到一些缓冲区字符

```
1.fflush(stdin)：VC上使用
2.setbuf(stdin,NULL):是stdin输入流由默认缓冲区转为无缓冲区
3.char ch;while((ch = getchar())!='\n'&& ch!=EOF):使用C语言的基本语法，支持任何场景
```
# 九. 进程的异步和同步实现
## 1. 线程条件变量（pthread）
```
- pthread_cond_init:初始化一个线程条件变量。
- pthread_cond_wait:等待条件触发。
- pthread_cond_signal:通知一个线程，线程条件发生。
- pthread_cond_timedwait:等待条件触发，可以设置超时时间。
- pthread_cond_reltimedwait_np:和pthread_cond_timedwait使用基本相同，区别是使用的是相对时间间隔而不是绝对时间间隔。
- pthread_cond_broadcast:通知所有等待线程，线程条件发生。
- pthread_cond_destroy:销毁条件变量
```
## 2. eventfd
```
int eventfd(unsigned int initval, int flags);

flags:
- EFD_CLOEXEC:设置该描述符的O_CLOEXEC标志。
- EFD_NONBLOCK:设置描述符为非阻塞模式。
- EFD_SEMAPHORE:设置描述符为信号量工作模式，在此模式下，read模式会使整型数减1并返回数值1。
``